---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  fig.align = "center",
  out.width = "75%"
)
```
# brolgar

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Travis build status](https://travis-ci.org/njtierney/brolgar.svg?branch=master)](https://travis-ci.org/njtierney/brolgar)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/njtierney/brolgar?branch=master&svg=true)](https://ci.appveyor.com/project/njtierney/brolgar)
[![Codecov test coverage](https://codecov.io/gh/njtierney/brolgar/branch/master/graph/badge.svg)](https://codecov.io/gh/njtierney/brolgar?branch=master)
<!-- badges: end -->

`brolgar` helps you **br**owse **o**ver **l**ongitudinal **d**ata **g**raphically and **a**nalytically in **R**, by providing tools to:

* Efficiently explore your raw data
* Calculate features (summaries) for each individual series
* Evaluate diagnostics of statistical models

This helps you go from the "plate of spaghetti" plot on the left, to "interesting observations" plot on the left.


```{r show-spaghetti, echo = FALSE, fig.height = 3, fig.width = 6}
library(brolgar)
library(ggplot2)
suppressPackageStartupMessages(library(gghighlight))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))

p1 <- ggplot(wages, 
       aes(x = xp, 
             y = ln_wages, 
             group = id)) + 
  geom_line()

p2 <- 
wages %>%
  features(ln_wages, feat_monotonic) %>%
  left_join(wages, by = "id") %>%
  ggplot(aes(x = xp,
             y = ln_wages,
             group = id)) +
  geom_line() + 
  gghighlight(increase)

gridExtra::grid.arrange(p1, p2, ncol = 2)

```



## Installation

Install from [GitHub](https://github.com/) with:

``` r
# install.packages("remotes")
remotes::install_github("njtierney/brolgar")
```

# Using `brolgar`: We need to talk about data

To efficiently look at your longitudinal data, we assume it **is a time series**, with **irregular** time periods between measurements. This might seem strange, (that's OK!), so **remember these two things**:

1. The **key** variable in your data is the **identifier** of your individuals or series.
2. The **index** variable is the **time** component of your data.

Together, the **index** and **key** uniquely identify an observation.

The term `key` is used a lot in brolgar, so it is an important idea to internalise:

> **The key is the identifier of your individuals or series**


So in the `wages` data, we have the following setup:

```{r setup-wages-ts, eval = FALSE}
wages <- as_tsibble(x = wages,
                       key = id,
                       index = xp,
                       regular = FALSE)
```



If you want to learn more about what longitudinal data as a time series, you can [read more in the vignette, "Longitudinal Data Structures"](library/brolgar/html/longitudinal-data-structures.html)

## Efficiently exploring longitudinal data

Exploring longitudinal data can be challenging. When there are many individuals it is difficult to look at all of them, as you often get a "plate of spaghetti" plot, with many lines plotted on top of each other. To avoid staring at a plate of spaghetti, you can look at a random subset of the data using tools in `brolgar`.

### `sample_n_keys()`

In `dplyr`, you can use `sample_n()` to sample `n` observations. Similarly, with `brolgar`, you can take a random sample of `n` keys using `sample_n_keys()`:

```{r plot-sample-n-keys}
set.seed(2019-7-15-1300)
wages %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = xp,
             y = ln_wages,
             group = id)) + 
  geom_line()
```

## Filtering observations

You can combine `sample_n_keys()` with `add_n_obs()` and `filter()` to only show keys with many observations:

```{r plot-filter-sample-n-keys}
set.seed(2019-7-15-1259)
library(dplyr)
wages %>%
  add_n_obs() %>%
  filter(n_obs > 5) %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = xp,
             y = ln_wages,
             group = id)) + 
  geom_line()
```

(Note: `sample_frac_keys()`, which samples a fraction of available keys.)

Now, how do you break these into many plots?

## Clever facets: `facet_strata()`

`brolgar` provides some clever facets to help make it easier to explore your data. `facet_strata()` splits the data into 12 groups by default:

```{r facet-strata}
set.seed(2019-07-23-1936)
library(ggplot2)
ggplot(wages,
       aes(x = xp,
           y = ln_wages,
           group = id)) +
  geom_line() +
  facet_strata()
```

But you could ask it to split the data into a more groups

```{r facet-strata-20}
set.seed(2019-07-25-1450)
library(ggplot2)
ggplot(wages,
       aes(x = xp,
           y = ln_wages,
           group = id)) +
  geom_line() +
  facet_strata(n_strata = 20)
```

And what if you want to show only a few samples per facet?

## Clever facets: `facet_sample()`

`facet_sample()` allows you to specify the number of keys per facet, and the number of facets with `n_per_facet` and `n_facets`. It splits the data into 12 facets with 5 per facet by default:

```{r facet-sample}
set.seed(2019-07-23-1937)
ggplot(wages,
       aes(x = xp,
           y = ln_wages,
           group = id)) +
  geom_line() +
  facet_sample()

```

But you can specify your own number:

```{r facet-sample-3-by-20}
set.seed(2019-07-25-1527)
ggplot(wages,
       aes(x = xp,
           y = ln_wages,
           group = id)) +
  geom_line() +
  facet_sample(n_per_facet = 3,
               n_facets = 20)

```

Under the hood, `facet_sample()` and `facet_strata()` use `sample_n_keys()` and `stratify_keys()`.

## Finding features in longitudinal data

You can extract `features` of longitudinal data using the `features` function, from `fablelite`. You can, for example, calculate the minimum of a given variable for each key by providing a named list like so:

```{r features-min}
wages %>%
  features(ln_wages, 
           list(min = min))
```

`brolgar` provides some sets of features, which start with `feat_`.

For example, the five number summary is `feat_five_num`:

```{r features-five-num}
wages %>%
  features(ln_wages, feat_five_num)
```

Or finding those whose values only increase or decrease with `feat_monotonic`

```{r features-monotonic}
wages %>%
  features(ln_wages, feat_monotonic)
```

## Linking individuals back to the data

You can join these features back to the data with `left_join`, like so:

```{r features-left-join}
wages %>%
  features(ln_wages, feat_monotonic) %>%
  left_join(wages, by = "id") %>%
  ggplot(aes(x = xp,
             y = ln_wages,
             group = id)) +
  geom_line() + 
  gghighlight(increase)
```

## Other helper functions

### `n_obs()`

We can calculate the number of observations total using `n_obs()`:

```{r example-n-obs}
n_obs(wages)
```

And the number of observations for each key using `n_keys()`:

```{r example-n-keys}
n_keys(wages)
```


You can also use `n_obs()` inside features to return the number of observations:

```{r n-obs-features}
wages %>%
  features(id, n_obs)
```


This returns a dataframe, with one row per key, and the number of observations for each key.

This could be further summarised to get a sense of the patterns of the number of observations:

```{r summarise-n-obs}
library(ggplot2)
wages %>%
  features(id, n_obs) %>%
ggplot(aes(x = n_obs)) + 
  geom_bar()

wages %>%
  features(id, n_obs) %>%
  summary()
```

### `add_n_obs()`

You can add information about the number of observations for each key with `add_n_obs()`:

```{r show-add-n-obs}
wages %>% add_n_obs()
```

Which you can then use to filter observations:

```{r show-add-obs-filter}
wages %>% 
  add_n_obs() %>%
  filter(n_obs > 3)
```

## Exploratory modelling

It can be useful to fit a model to explore your data. One technique is to fit a linear model for each group in a dataset. For example, you could fit a linear model for each key in the data.

`brolgar` provides a simple helper function to help with this, called `key_slope()`. 

`key_slope()` returns the intercept and slope estimate for each key, given a linear model formula. We can get the number of observations, and slope information for each individual to identify those that are decreasing over time. 

```{r use-gghighlight}
key_slope(wages,ln_wages ~ xp)
```

We can then join these summaries back to the data:

```{r show-wages-lg}
library(dplyr)
wages_slope <- key_slope(wages,ln_wages ~ xp) %>%
  left_join(wages, by = "id") 

wages_slope
```

And highlight those individuals with a negative slope using `gghighlight`:

```{r use-gg-highlight}
library(gghighlight)

wages_slope %>% 
  as_tibble() %>% # workaround for gghighlight + tsibble
  ggplot(aes(x = xp, 
             y = ln_wages, 
             group = id)) + 
  geom_line() +
  gghighlight(.slope_xp < 0)
```

### Find keys near other summaries with `keys_near()`

We might want to further summarise our exploratory modelling by finding those slopes that are near a five number summary values:

```{r summary-slope}
summary(wages_slope$.slope_xp)
```

Finding those groups that are near these values can be surprisingly challenging!

`brolgar` makes it easier by providing the `keys_near()` function. You tell it what the key is, what variable you want to summarse by, and then by default it returns those keys near the five number summary. Let's return the keys near the `.slope_xp`:

```{r keys-near}
wages_slope %>%
  keys_near(key = id,
            var = .slope_xp)
```

Here it returns the `id`, the `.slope_xp`, and the statistic that it was closest to, and what the difference between the slope_xp and the statistic.

You can visualise these summary keys by joining them back to the data:

```{r keys-near-plot}
wages_slope %>%
  keys_near(key = id,
            var = .slope_xp) %>%
  left_join(wages, by = "id") %>%
  ggplot(aes(x = xp,
             y = ln_wages,
             group = id,
             colour = stat)) + 
  geom_line()
```


You can read more about `keys_near()` at the [finding summary keys vignette](http://brolgar.njtierney.com/articles/find-summary-keys.html).

# Contributing

Please note that the `brolgar` project is released with a
[Contributor Code of Conduct](.github/CODE_OF_CONDUCT.md).
By contributing to this project, you agree to abide by its terms.

# A Note on the API

This version of brolgar was been forked from [tprvan/brolgar](https://github.com/tprvan/brolgar), and has undergone breaking changes to the API.

<!-- These are referred to as a **longnostics**, a portmanteau of **long**itudinal and **cognostic**. These **longnostics** make it straightforward to extract subjects with certain properties to gain some insight into the data.  -->


<!-- But calculating this for individuals draws you away from your analysis, and instead you are now wrangling with a different problem: summarising key information about each individual and incorporating that back into the data.  -->

<!-- This is annoying, and distracts from your analysis, inviting errors. -->


