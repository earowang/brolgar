---
title: "Stats on Stats: Workflows with `brolgar`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stats on Stats: Workflows with `brolgar`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r establish-chunk-opts, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
  )
```

```{r setup}
library(brolgar)
```

To better understand longitudinal data we can think about some of the exploratory data analysis happening over three datasets:

1. The full data, which contain profiles of the longitudinal observations
2. The features, which contain the summary features for each unique key that identifies a group
3. The statistics on the features.

These are "stats on stats" of longitudinal data.

Let's expand on this.

## The full data

We have the full set of data, which we can look at in "full spaghetti" form like so:

```{r full-spaghetti}
library(ggplot2)
ggplot(wages_ts,
       aes(x = xp,
           y = ln_wages,
           group = id)) + 
  geom_line()
```

So here we have our data
```{r top-tail}
head(wages_ts)
tail(wages_ts)
```

## The Features

Now we can consider the features, just say for example we are only interested in the maximum of `ln_wages`, we can do the following:

```{r wages-lnw-max}
max_wages <- wages_ts %>% features(ln_wages, list(max = max))
```

## The statistics on features

And from here we can explore the features - what is the distribution of the maximum values?

```{r plot-max}
ggplot(max_wages,
       aes(x = max)) + 
  geom_density()
```

We can get the summary of these:

```{r summary-max}
summary(max_wages$max)
```

And now we want to identify those individuals who are at, or closest to the quartiles using `keys_near()`.

```{r stats-on-stats-libs}
library(purrr)
library(tidyr)
library(dplyr)
library(brolgar)
library(glue)
```

```{r}
quantiles_near <- keys_near(max_wages,
                            key = id,
                            var = max,
                            funs = l_three_num)
```


```{r stats-on-stats}
max_quants <- quantile(x = max_wages[["max"]],
                       probs = c(0.25, 0.5, 0.75))

part_near <- partial(near,
                     y = max_wages[["max"]],
                     tol = 0.05)



summarise_l_max_wages <- max_wages %>%
  summarise(id = list(id), 
            qs = list(as.list(quantile(x = max,
                                       probs = c(0.25, 0.5, 0.75),
                                       type = 7)))
  )

l_max_wages_near <- summarise_l_max_wages %>%
  mutate(is_near = list(map_dfr(flatten(qs), part_near))) %>% 
  select(id, is_near) %>%
  unnest() %>%
  gather(key = "near_q",
         value = "value",
         2:4,
         -id) %>%
  mutate(quant_is_near = case_when(
    value ~ glue::glue("q_{readr::parse_number(near_q)}")
  )) %>%
  filter(!is.na(quant_is_near))

l_max_wages_near
```

```{r show-same}
wages %>%
  inner_join(l_max_wages_near, by = "id") %>%
  ggplot(aes(x = exper,
             y = lnw,
             group = id,
             colour = near_q)) + 
  geom_line() + 
  facet_wrap(~near_q)
```

```{r wages-longnostic-all}

l_wages_all <- longnostic_all(wages,
                              id = id,
                              var = lnw,
                              formula = lnw ~ exper)

l_wages_all %>%
  filter(!is.na(l_slope_exper)) %>%
  select(id, l_slope_exper) %>%
  mutate(q50 = quantile(l_slope_exper, 0.5, type = 7)) %>%
  mutate(near_q50 = near_quantile(x = l_slope_exper,
                                  probs = c(0.5),
                                  tol = 0.001)) %>%
  mutate(dist_q50 = abs(l_slope_exper - quantile(l_slope_exper, 
                                                 probs = 0.5, 
                                                 type = 7))) %>%
  arrange(dist_q50)
```
